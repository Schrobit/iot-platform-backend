# 消息模型与通信规范

> 2025-12-27 created by Schrobit

## 1. 文档目的

本文档用于统一系统内各组件之间的**消息格式、通信方式与交互规范**，
确保设备、网关、中转服务器、消息队列以及后端服务在数据交换层面具有一致理解。

本文档重点关注：
- 消息的结构与字段含义
- 上行与下行消息的统一模型
- 不同通信通道之间的职责划分

本文档不涉及具体消息队列部署参数或网络安全配置细节。

---

## 2. 系统通信总体架构

系统通信链路按照数据流方向划分为两类：

### 2.1 上行链路（Uplink）

```text
设备 → WebSocket → 设备网关
     → MQTT → MQTT Broker
     → 中转服务器
     → AMQP → RabbitMQ（uplink.queue）
     → 后端服务
````

### 2.2 下行链路（Downlink）

```text
后端服务
→ RabbitMQ（downlink.queue）
→ 中转服务器
→ MQTT → MQTT Broker
→ WebSocket → 设备网关
→ 设备 / 执行机构
```

系统采用**逻辑对称的上下行通信路径**，
便于理解、实现与调试。

---

## 3. 消息队列设计

### 3.1 交换机与队列

* 交换机：默认交换机（Direct）
* 上行队列：`uplink.queue`
* 下行队列：`downlink.queue`
* 路由键：与队列名一致

**设计说明**

* 默认交换机即可满足当前需求
* 不引入额外交换机以降低复杂度
* 后续可无感升级为 Topic 或 Fanout 交换机

---

### 3.2 消息投递原则

* 上行消息只写入 `uplink.queue`
* 下行消息只写入 `downlink.queue`
* 消息体采用 JSON 格式
* 不在消息层面实现复杂路由逻辑

---

## 4. 通用消息结构

系统内所有消息均遵循统一的基础结构：

```json
{
  "msg_type": "string",
  "device_id": "string",
  "timestamp": "ISO8601",
  "payload": {}
}
```

### 字段说明

| 字段        | 说明              |
| --------- | --------------- |
| msg_type  | 消息类型，用于区分遥测、控制等 |
| device_id | 目标或来源设备标识       |
| timestamp | 消息产生时间          |
| payload   | 具体业务数据          |

---

## 5. 上行消息模型（Uplink）

### 5.1 遥测数据消息

**msg_type**

```text
telemetry
```

**示例**

```json
{
  "msg_type": "telemetry",
  "device_id": "dev-001",
  "timestamp": "2025-01-01T10:00:00Z",
  "payload": {
    "value": 22.3,
    "unit": "C"
  }
}
```

**说明**

* 该消息用于设备上报环境监测数据
* 消息可能高频产生
* 后端应优先写入时序数据库

---

### 5.2 设备状态消息（可选）

**msg_type**

```text
status
```

**示例**

```json
{
  "msg_type": "status",
  "device_id": "dev-001",
  "timestamp": "2025-01-01T10:00:10Z",
  "payload": {
    "online": true
  }
}
```

**说明**

* 用于表示设备在线/离线等状态变化
* 更新频率低
* 可用于维护设备运行状态

---

## 6. 下行消息模型（Downlink）

### 6.1 控制命令消息

**msg_type**

```text
command
```

**示例**

```json
{
  "msg_type": "command",
  "device_id": "dev-010",
  "timestamp": "2025-01-01T10:05:00Z",
  "payload": {
    "command": "set_target",
    "params": {
      "target": 22.0
    }
  }
}
```

**说明**

* 控制命令由管理员触发
* 消息通过下行链路发送至设备
* 当前阶段不要求设备返回 ACK

---

## 7. WebSocket 通信约定（设备 ↔ 网关）

### 7.1 连接原则

* 上行遥测与下行控制共用同一 WebSocket 连接
* WebSocket 为长连接
* 消息通过 `msg_type` 区分方向与用途

**设计说明**

* 减少连接数量
* 简化设备端实现
* 保证通信时序一致性

---

### 7.2 WebSocket 消息示例

#### 上行（设备 → 网关）

```json
{
  "msg_type": "telemetry",
  "payload": {
    "value": 45.0,
    "unit": "%RH"
  }
}
```

#### 下行（网关 → 设备）

```json
{
  "msg_type": "command",
  "payload": {
    "command": "set_state",
    "params": {
      "state": "open"
    }
  }
}
```

---

## 8. 消息可靠性与边界说明

当前阶段系统明确：

* 不实现消息重试与死信队列
* 不保证消息的“至少一次 / 恰好一次”语义
* 不进行消息顺序严格控制
* 不在消息层实现权限校验

上述能力可在后续阶段逐步引入。

---

## 9. 消息模型扩展预留

系统在消息模型层面预留以下扩展能力：

* 增加 `trace_id` 用于全链路追踪
* 增加 `ack` / `error` 消息类型
* 引入 Topic 交换机支持多级路由
* 引入 QoS 或确认机制

---

## 10. 小结

通过统一的消息模型与通信规范，
系统实现了：

* 上下行通信路径对称清晰
* 消息格式简单、易于扩展
* 设备、网关与后端之间的解耦

本文档为后续**接口模型设计**与**系统实现阶段**
提供了稳定可靠的通信基础。
